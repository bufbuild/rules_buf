package buf

import (
	"fmt"

	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

const lintRuleKind = "buf_lint_test"

type lintRule struct{}

func newLintRule() lintRule {
	return lintRule{}
}

func (lintRule) Kind() string {
	return lintRuleKind
}

func (lintRule) KindInfo() rule.KindInfo {
	return rule.KindInfo{
		MatchAttrs: []string{"targets"},
		MergeableAttrs: map[string]bool{
			"config": true,
		},
	}
}

func (lintRule) LoadInfo() rule.LoadInfo {
	return rule.LoadInfo{
		Name:    "@rules_buf//buf:defs.bzl",
		Symbols: []string{lintRuleKind},
	}
}

func (lr lintRule) GenerateRules(args language.GenerateArgs) (res language.GenerateResult) {
	cfg := GetConfigForGazelleConfig(args.Config)
	// Skip if we are in any of the excludes directories
	if isWithinExcludes(cfg, args.Rel) {
		return
	}
	protoLibRules := getRulesOfKind(args.OtherGen, "proto_library")
	for _, plr := range protoLibRules {
		res.Gen = append(res.Gen, lr.genRule(plr.Name(), cfg))
		res.Imports = append(res.Imports, struct{}{})
	}
	if args.File != nil {
		breakingRules := getRulesOfKind(args.File.Rules, breakingRuleKind)
		for _, r := range breakingRules {
			targets := r.AttrStrings("targets")
			if len(targets) > 1 {
				// Not generated by us
				continue
			}
			if len(targets) == 1 && protoLibRules[targets[0]] != nil {
				// Target is accurate so skip
				continue
			}
			res.Empty = append(res.Empty, r)
		}
	}
	return
}

// GenRule returns a list of rules that need be generated for each `proto_library` rule.
func (lintRule) genRule(name string, c *Config) *rule.Rule {
	r := rule.NewRule("buf_lint_test", fmt.Sprintf("%s_lint", name))
	r.SetAttr("targets", []string{fmt.Sprintf(":%s", name)})
	if c.Module != nil {
		r.SetAttr("config", c.ConfigFile.String())
	}
	return r
}
