package buf

import (
	"fmt"
	"io/fs"
	"os"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

func (*bufLang) Fix(c *config.Config, f *rule.File) {}

func (*bufLang) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	var (
		res    = language.GenerateResult{}
		config = GetConfigForGazelleConfig(args.Config)
	)
	// Skip if we are in any of the excludes directories
	if isWithinExcludes(config, args.Rel) {
		return res
	}
	protoRuleMap := make(map[string]*rule.Rule, len(args.OtherGen))
	// Lint and breaking package mode
	for _, rule := range args.OtherGen {
		if rule.Kind() != "proto_library" {
			continue
		}
		protoRuleMap[rule.Name()] = rule
		protoTarget := rule.Name()
		res.Gen = append(res.Gen, generateLintRule(config, protoTarget))
		res.Imports = append(res.Imports, struct{}{})
		// Skip if module mode
		if config.BreakingMode == BreakingModeModule {
			continue
		}
		res.Gen = append(res.Gen, generateBreakingRule(config, protoTarget))
		res.Imports = append(res.Imports, struct{}{})
	}
	if config.ModuleRoot && config.BreakingMode == BreakingModeModule {
		breakingRule := generateBreakingRule(config, "buf")
		res.Gen = append(res.Gen, breakingRule)
		res.Imports = append(res.Imports, getProtoImportPaths(config, args.Dir))
	}
	// Stale rules to remove
	if args.File != nil {
		for _, rule := range args.File.Rules {
			// proto_library targets are mapped one to one for lint and breaking rules in package mode
			if rule.Kind() == lintRuleKind ||
				(rule.Kind() == breakingRuleKind &&
					config.BreakingMode == BreakingModePackage) {
				if shouldRemoveSingleTargetBufRule(
					protoRuleMap,
					rule,
				) {
					res.Empty = append(res.Empty, rule)
				}
				continue
			}
			// If it is breaking rule it will also be managed mode
			// In module mode delete all
			if rule.Kind() == breakingRuleKind {
				res.Empty = append(res.Empty, rule)
			}
		}
	}
	return res
}

func generateLintRule(config *Config, target string) *rule.Rule {
	r := rule.NewRule("buf_lint_test", fmt.Sprintf("%s_lint", target))
	r.SetAttr("targets", []string{fmt.Sprintf(":%s", target)})
	if config.Module != nil {
		r.SetAttr("config", config.BufConfigFile.String())
	}
	return r
}

func generateBreakingRule(config *Config, target string) *rule.Rule {
	r := rule.NewRule(breakingRuleKind, fmt.Sprintf("%s_breaking", target))
	r.SetAttr("targets", []string{fmt.Sprintf(":%s", target)})
	r.SetAttr("against", config.BreakingImageTarget)
	// Set optional attributes
	if !config.BreakingExcludeImports {
		r.SetAttr("exclude_imports", false)
	}
	if config.BreakingMode == BreakingModeModule {
		r.SetAttr("limit_to_input_files", false)
	}
	if config.Module != nil {
		r.SetAttr("config", config.BufConfigFile.String())
	}
	return r
}

// shouldRemoveSingleTargetBufRule checks if lint and breaking rules in package mode need to be removed
func shouldRemoveSingleTargetBufRule(
	protoRuleMap map[string]*rule.Rule,
	bufRule *rule.Rule,
) bool {
	targets := bufRule.AttrStrings("targets")
	if len(targets) > 1 {
		// Not generated by us
		return false
	}
	if len(targets) == 1 && protoRuleMap[targets[0]] != nil {
		// Target is accurate so skip
		return false
	}
	return true
}

func getProtoImportPaths(config *Config, moduleRoot string) []string {
	var targets []string
	fs.WalkDir(
		os.DirFS(moduleRoot),
		".",
		func(path string, dirEntry fs.DirEntry, err error) error {
			if dirEntry.IsDir() {
				return nil
			}
			if !strings.HasSuffix(dirEntry.Name(), ".proto") {
				return nil
			}
			// Skip if we are in any of the excludes directories
			if isWithinExcludes(config, path) {
				return nil
			}
			targets = append(targets, path)
			return nil
		},
	)
	return targets
}
