# Gazelle extension for rules_buf

[Gazelle](https://github.com/bazelbuild/bazel-gazelle) extension for `rules_buf`. It can,

- Generate `buf_lint_test` rules.
- Generate `buf_breaking_test` rules.

## Setup

**Prerequisites**

- Setup `rules_buf` as per the instructions on the [readme](/README.md)
- Setup `gazelle` as detailed [here](https://github.com/bazelbuild/bazel-gazelle#setup)

Add the following code snippet at the end of the `WORKSPACE` file:
```starlark
load("@rules_buf//gazelle/buf:repositories.bzl", "gazelle_buf_dependencies")

gazelle_buf_dependencies()
```

Then in the root `BUILD` file, add the following targets:
```starlark
load("@bazel_gazelle//:def.bzl", "DEFAULT_LANGUAGES", "gazelle", "gazelle_binary")

gazelle_binary(
    name = "gazelle-buf",    
    languages = DEFAULT_LANGUAGES + [
        "@rules_buf//gazelle/buf:buf",
    ],
    visibility = ["//:__pkg__"],
)

gazelle(
    name = "gazelle",
    gazelle = ":gazelle-buf",
)
```

The `proto` language is needed and should precede the buf extension.

Now run `gazelle`:
```bash
bazel run //:gazelle
```

## `buf_lint_test`

Running `gazelle` will create a `buf_lint_test` for each of the `proto_library` target that is generated by gazelle. 

It will pick up the config from the nearest `buf.yaml` file it can find going up to the root. The `buf.yaml` file should be exported. It can be done using `exports_files(["buf.yaml"])`.

## `buf_breaking_test`

For breaking change `buf_breaking_test` to be generated `gazelle` requires an image to compare against. This can be configured for each buf module independently.

`# gazelle:buf_breaking_against image_file_target`

This directive should be specified in the package containing `buf.yaml`.

It will pick up the config from the nearest `buf.yaml` file it can find going up to the root. The `buf.yaml` file should be exported. It can be done using `exports_files(["buf.yaml"])`.

`buf_breaking_test` can run in two different modes.

### Module mode (Preferred)

In this mode only one `buf_breaking_test` rule is added for each `buf.yaml` file. This will check all the `proto_library` that come under a buf module. Unlike package mode, any deleted files/packages can be caught.

### Package mode

To enable this add the following directive,

`# gazelle:buf_breaking_mode package`

This is the `bazel` way. `buf_breaking_test` rules are generated against each `proto_library` target. When these are run, they only check whether the protocol buffers have changed within each package.

**Example**

Let's consider a buf module with the following directory structure:

```bash
|- buf.yaml
|- BUILD
|- foo
|  |- v1
|     |- foo.proto
|     |- BUILD
|- bar
   |- v1
      |- bar.proto
      |- BUILD
```

In package mode `buf_breaking_test` rules are generated in both `foo/v1` and `bar/v1` against their respective `proto_library` targets. If a breaking change occurs in either `foo.proto` or `bar.proto` the tests will catch them.

However, if `foo/v1` gets deleted, it will be a breaking change for the module as a whole. Unfortunately this can never be detected using this setup. 

To mitigate this it is recommend to run gazelle in module mode(default).

## Workspaces

Workspaces are supported. However, for the `proto` extension to generate `proto_library` rules with accurate import paths, one has to strip the path leading up to the buf module. This can be done using the gazelle directive `proto_strip_import_prefix`

**Example**

Let's consider a buf workspace with the following directory structure:

```bash
|- buf.work.yaml
|- BUILD
|- fooapis
|  |- buf.yaml
|  |- BUILD
|  |- foo/...
|- barapis
|  |- buf.yaml
|  |- BUILD
|  |- bar/...
```

For the `proto_library` rules to be generated with the accurate import paths we need to add the following directives:

`fooapis/BUILD`
```starlark
# gazelle:proto_strip_import_prefix /fooapis

exports_files(["buf.yaml"])
```

`barapis/BUILD`
```starlark
# gazelle:proto_strip_import_prefix /barapis

exports_files(["buf.yaml"])
```

Run `gazelle` as usual:
```bash
bazel run //:gazelle
``` 